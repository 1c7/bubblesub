# bubblesub - ASS subtitle editor
# Copyright (C) 2018 Marcin Kurczewski
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

"""ASS file writer."""

import functools
import typing as T
from collections import OrderedDict
from decimal import Decimal
from pathlib import Path

from bubblesub.fmt.ass.event import AssEvent
from bubblesub.fmt.ass.file import AssFile
from bubblesub.fmt.ass.style import AssColor, AssStyle
from bubblesub.fmt.ass.util import escape_ass_tag
from bubblesub.util import ms_to_times

NOTICE = (
    "Script generated by bubblesub\nhttps://github.com/bubblesub/bubblesub"
)


def _serialize_text(text: str) -> str:
    return text.replace(",", ";")


def _serialize_color(col: AssColor) -> str:
    return f"&H{col.alpha:02X}{col.blue:02X}{col.green:02X}{col.red:02X}"


def _serialize_integer(value: int) -> str:
    return f"{value:d}"


def _serialize_float(value: T.Union[int, float]) -> str:
    dec = Decimal(str(value))
    if dec == dec.to_integral():
        return str(dec.quantize(Decimal(1)))
    return str(dec.normalize())


def _ms_to_timestamp(milliseconds: int) -> str:
    hours, minutes, seconds, milliseconds = ms_to_times(milliseconds)
    return f"{hours:01d}:{minutes:02d}:{seconds:02d}.{milliseconds // 10:02d}"


def write_meta(ass_file: AssFile, handle: T.IO[str]) -> None:
    """Write ASS meta to a file.

    :param ass_file: ASS file to take the metadata from
    :param handle: handle to write the metadata to
    """
    meta: T.Dict[str, str] = OrderedDict()
    meta["ScriptType"] = "sentinel"  # make sure script type is the first entry
    meta.update(ass_file.meta.items())
    meta["ScriptType"] = "v4.00+"

    print("[Script Info]", file=handle)
    for line in NOTICE.splitlines(False):
        print(";", line, file=handle)
    for key, value in meta.items():
        print(key, "" if value is None else value, sep=": ", file=handle)


def write_styles(ass_file: AssFile, handle: T.IO[str]) -> None:
    """Write ASS styles to a file.

    :param ass_file: ASS file to take the styles from
    :param handle: handle to write the styles to
    """
    print("[V4+ Styles]", file=handle)
    print(
        "Format: Name, Fontname, Fontsize, PrimaryColour, "
        "SecondaryColour, OutlineColour, BackColour, Bold, Italic, "
        "Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, "
        "BorderStyle, Outline, Shadow, Alignment, "
        "MarginL, MarginR, MarginV, Encoding",
        file=handle,
    )
    for style in ass_file.styles:
        write_style(style, handle)


@functools.lru_cache(maxsize=1024)
def serialize_style(style: AssStyle) -> str:
    """Serializes ASS style to plain text.

    :param style: ASS style to serialize
    :return: serialized ASS style
    """
    return "Style: " + ",".join(
        [
            _serialize_text(style.name),
            _serialize_text(style.font_name),
            _serialize_integer(style.font_size),
            _serialize_color(style.primary_color),
            _serialize_color(style.secondary_color),
            _serialize_color(style.outline_color),
            _serialize_color(style.back_color),
            "-1" if style.bold else "0",
            "-1" if style.italic else "0",
            "-1" if style.underline else "0",
            "-1" if style.strike_out else "0",
            _serialize_float(style.scale_x),
            _serialize_float(style.scale_y),
            _serialize_float(style.spacing),
            _serialize_float(style.angle),
            _serialize_integer(style.border_style),
            _serialize_float(style.outline),
            _serialize_float(style.shadow),
            _serialize_integer(style.alignment),
            _serialize_integer(style.margin_left),
            _serialize_integer(style.margin_right),
            _serialize_integer(style.margin_vertical),
            _serialize_integer(style.encoding),
        ]
    )


def write_style(style: AssStyle, handle: T.IO[str]) -> None:
    """Write ASS style to a file.

    :param style: ASS style to write
    :param handle: handle to write the style to
    """
    print(serialize_style(style), file=handle)


def write_events(ass_file: AssFile, handle: T.IO[str]) -> None:
    """Write ASS events to a file.

    :param ass_file: ASS file to take the events from
    :param handle: handle to write the events to
    """
    print("[Events]", file=handle)
    print(
        "Format: Layer, Start, End, Style, Name, "
        "MarginL, MarginR, MarginV, Effect, Text",
        file=handle,
    )
    for event in ass_file.events:
        write_event(event, handle)


@functools.lru_cache(maxsize=1024)
def serialize_event(event: AssEvent) -> str:
    """Serializes ASS event to plain text.

    :param event: ASS event to serialize
    :return: serialized ASS event
    """
    text = event.text

    if event.start is not None and event.end is not None:
        text = "{TIME:%d,%d}" % (event.start, event.end) + text

    if event.note:
        text += "{NOTE:%s}" % escape_ass_tag(event.note.replace("\n", "\\N"))

    event_type = "Comment" if event.is_comment else "Dialogue"
    return (
        event_type
        + ": "
        + ",".join(
            [
                _serialize_integer(event.layer),
                _ms_to_timestamp(event.start),
                _ms_to_timestamp(event.end),
                _serialize_text(event.style),
                _serialize_text(event.actor),
                _serialize_integer(event.margin_left),
                _serialize_integer(event.margin_right),
                _serialize_integer(event.margin_vertical),
                _serialize_text(event.effect),
                text,
            ]
        )
    )


def write_event(event: AssEvent, handle: T.IO[str]) -> None:
    """Write ASS event to a file.

    :param event: ASS event to write
    :param handle: handle to write the event to
    """
    print(serialize_event(event), file=handle)


def write_ass(ass_file: AssFile, target: T.Union[Path, T.IO[str]]) -> None:
    """Save ASS to the specified target.

    :param ass_file: file to save
    :param target: writable stream or a path
    """
    if isinstance(target, Path):
        with target.open("w") as handle:
            write_ass(ass_file, handle)
            return

    write_meta(ass_file, target)
    print("", file=target)
    write_styles(ass_file, target)
    print("", file=target)
    write_events(ass_file, target)
