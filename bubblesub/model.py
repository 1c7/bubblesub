# bubblesub - ASS subtitle editor
# Copyright (C) 2018 Marcin Kurczewski
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

"""Common containers, decorators, etc."""

import typing as T

from PyQt5 import QtCore

TItem = T.TypeVar("TItem")  # pylint: disable=invalid-name


class classproperty(property):
    """
    Combine @property and @classmethod.

    >>> class foo:
    ...     @classproperty
    ...     def number(cls):
    ...         return 5
    ...
    >>> foo.number
    5
    """

    def __init__(self, func: T.Callable[[type], TItem]) -> None:
        """
        Initialize self.

        :param func: getter function, which accepts class type as
            its only argument
        """
        super().__init__()
        self.func = func

    def __get__(self, cls: object, owner: type) -> TItem:
        """
        Invoke the getter function.

        :param cls: (unused)
        :param owner: parent object
        :return: getter's result
        """
        return self.func(owner)


class ObservableObject:
    """Class capable of observing changes to its properties."""

    def __init__(self) -> None:
        """Initialize self."""
        self._setattr_impl = self._setattr_normal
        self._dirty = False

    def __setattr__(self, prop: str, new_value: T.Any) -> None:
        """
        Set attribute.

        Called whenever the user changes any of the class attributes.
        Changes to properties starting with _ won't be tracked.
        Changes to other properties will trigger self._after_change callback.

        :param prop: property name
        :param new_value: new value
        """
        if prop.startswith("_"):
            super().__setattr__(prop, new_value)
        else:
            try:
                old_value = getattr(self, prop)
            except AttributeError:
                super().__setattr__(prop, new_value)
            else:
                if new_value != old_value:
                    self._setattr_impl(prop, new_value)

    def _setattr_normal(self, prop: str, new_value: T.Any) -> None:
        """
        Regular implementation of attribute setter.

        Calls _after_change immediately.

        :param prop: property name
        :param new_value: new value
        """
        super().__setattr__(prop, new_value)
        self._after_change()

    def _setattr_throttled(self, prop: str, new_value: T.Any) -> None:
        """
        Throttled implementation of attribute setter.

        Doesn't call _after_change until after the user calls the .end_update()
        method.

        :param prop: property name
        :param new_value: new value
        """
        super().__setattr__(prop, new_value)
        self._dirty = True

    def begin_update(self) -> None:
        """
        Start throttling calls to ._after_change() method.

        Useful for batch object updates - rather than having .after_change()
        method called after every change to the instance properties, it's
        getting called only once, on .end_update().
        """
        self._setattr_impl = self._setattr_throttled

    def end_update(self) -> None:
        """
        Stop throttling calls to ._after_change() method.

        If the object was modified in the meantime, calls ._after_change()
        method only once.
        """
        if self._dirty:
            self._after_change()
        self._setattr_impl = self._setattr_normal
        self._dirty = False

    def _after_change(self) -> None:
        """
        Meant to be overriden by the user.

        Called after class properties have changed.
        """
        pass


class ObservableListSignals(QtCore.QObject):
    """
    Helper class proxying events generated by ObservableList.

    Works around problem with multiple inheritance - pyqtSignal needs the class
    to derive from QtCore.QObject, which doesn't play nice with typing
    annotations required by ObservableList.
    """

    items_about_to_be_inserted = QtCore.pyqtSignal([int, int])
    items_about_to_be_removed = QtCore.pyqtSignal([int, int])
    items_inserted = QtCore.pyqtSignal([int, int])
    items_removed = QtCore.pyqtSignal([int, int])
    item_changed = QtCore.pyqtSignal([int])


class ObservableList(T.Generic[TItem]):  # pylint: disable=E1136
    """Alternative to QtCore.QAbstractListModel that simplifies indexing."""

    def __init__(self) -> None:
        """Initialize self."""
        super().__init__()
        self._signals = ObservableListSignals()
        self._items: T.List[TItem] = []

    @property
    def items_about_to_be_inserted(self) -> QtCore.pyqtSignal:
        """
        Proxy items_about_to_be_inserted event.

        :return: signal
        """
        return self._signals.items_about_to_be_inserted

    @property
    def items_about_to_be_removed(self) -> QtCore.pyqtSignal:
        """
        Proxy items_about_to_be_removed event.

        :return: signal
        """
        return self._signals.items_about_to_be_removed

    @property
    def items_inserted(self) -> QtCore.pyqtSignal:
        """
        Proxy items_inserted event.

        :return: signal
        """
        return self._signals.items_inserted

    @property
    def items_removed(self) -> QtCore.pyqtSignal:
        """
        Proxy items_removed event.

        :return: signal
        """
        return self._signals.items_removed

    @property
    def item_changed(self) -> QtCore.pyqtSignal:
        """
        Proxy items_changed event.

        :return: signal
        """
        return self._signals.item_changed

    def __getstate__(self) -> T.Any:
        """
        Return pickle compatible object representation.

        :return: object representation
        """
        return self._items

    def __setstate__(self, state: T.Any) -> None:
        """
        Load class state from pickle compatible object representation.

        :param state: object representation
        """
        self._items = state

    def __len__(self) -> int:
        """
        Return how many items the collection contains.

        :return: number of items
        """
        return len(self._items)

    @T.overload
    def __getitem__(self, idx: slice) -> T.List[TItem]:
        """
        Retrieve item at given position.

        :param idx: item position
        :return: value at given position
        """
        ...  # pylint: disable=pointless-statement

    @T.overload
    def __getitem__(self, idx: int) -> TItem:
        """
        Retrieve item at given position.

        :param idx: item position
        :return: value at given position
        """
        ...  # pylint: disable=pointless-statement

    def __getitem__(self, idx):
        """
        Retrieve item at given position.

        :param idx: item position
        :return: value at given position
        """
        return self._items[idx]

    def __setitem__(self, idx: T.Union[slice, int], value: T.Any) -> None:
        """
        Set item at given position.

        :param idx: position to modify
        :param value: new value
        """
        if isinstance(idx, slice):
            raise RuntimeError("slice assignment is not supported")
        else:
            self._items[idx] = value
            self.item_changed.emit(idx)

    def __iter__(self) -> T.Iterator[TItem]:
        """
        Iterate directly over the collection values.

        :return: iterator
        """
        yield from self._items

    def get(
        self, idx: int, default: T.Optional[TItem] = None
    ) -> T.Optional[TItem]:
        """
        Retrieve item at given position.

        :param idx: item's position
        :param default: value to return if position is out of bounds
        :return: value at given position, default if position out of bounds
        """
        if idx < 0 or idx >= len(self):
            return default
        return self._items[idx]

    def index(self, item: TItem) -> T.Optional[int]:
        """
        Look up item's position in the collection.

        :param item: item to look up
        :return: item's position if found, None otherwise
        """
        for idx, other_item in enumerate(self._items):
            if other_item == item:
                return idx
        return None

    def append(self, *items: TItem) -> None:
        """
        Insert new values at the end of the list.

        Emits items_about_to_be_inserted items_inserted events.

        :param items: items to append
        """
        self.insert(len(self), *items)

    def insert(self, idx: int, *items: TItem) -> None:
        """
        Insert new values at given position.

        Emits items_about_to_be_inserted and items_inserted events.

        :param idx: where to put the new items
        :param items: items to insert
        """
        if not items:
            return
        self.items_about_to_be_inserted.emit(idx, len(items))
        self._items = self._items[:idx] + list(items) + self._items[idx:]
        self.items_inserted.emit(idx, len(items))

    def remove(self, idx: int, count: int) -> None:
        """
        Remove part of the collection's content.

        Emits items_about_to_be_removed and items_removed events.

        :param idx: where to start the removal
        :param count: how many elements to remove
        """
        self.items_about_to_be_removed.emit(idx, count)
        self._items = self._items[:idx] + self._items[idx + count :]
        self.items_removed.emit(idx, count)

    def clear(self) -> None:
        """
        Clear the entire collection.

        Emits items_about_to_be_removed and items_removed events.
        """
        self.remove(0, len(self))

    def move(self, idx: int, new_idx: int) -> None:
        """
        Move one item to a new position.

        Emits items_removed and items_inserted events.

        :param idx: source position
        :param new_idx: target position
        """
        item = self._items[idx]
        self.remove(idx, 1)
        self.insert(new_idx, item)

    def replace(self, values: T.List[TItem]) -> None:
        """
        Replace the entire collection with new content.

        Emits items_about_to_be_removed, items_removed,
        items_about_to_be_inserted and items_inserted events.

        :param values: new content
        """
        self.clear()
        self.insert(0, *values)
