import re
import typing as T
from collections import OrderedDict

from bubblesub.util import ms_to_times
from .event import EventList
from .style import StyleList, Color
from .util import unescape_ass_tag, escape_ass_tag

NOTICE = 'Script generated by bubblesub\nhttps://github.com/rr-/bubblesub'
TIMESTAMP_RE = re.compile(r'(\d{1,2}):(\d{2}):(\d{2})[.,](\d{2,3})')
SECTION_HEADING_RE = re.compile(r'^\[[^\]]+\]')


def _color_to_ass_rgba(col: Color) -> str:
    return f'&H{col.alpha:02X}{col.blue:02X}{col.green:02X}{col.red:02X}'


def _ass_rgba_to_color(text: str) -> Color:
    val = int(text[2:], base=16)
    red = val & 0xFF
    green = (val >> 8) & 0xFF
    blue = (val >> 16) & 0xFF
    alpha = (val >> 24) & 0xFF
    return Color(red, green, blue, alpha)


class EventMeta:
    def __init__(
            self,
            text: str,
            note: str,
            start: T.Optional[int],
            end: T.Optional[int],
    ) -> None:
        self.text = text
        self.note = note
        self.start = start
        self.end = end


def _unpack_event_meta(text: str) -> EventMeta:
    meta = EventMeta(text=text, note='', start=None, end=None)

    match = re.search(r'{NOTE:(?P<note>[^}]*)}', meta.text)
    if match:
        meta.text = meta.text[:match.start()] + meta.text[match.end():]
        meta.note = unescape_ass_tag(match.group('note'))

    match = re.search(r'{TIME:(?P<start>-?\d+),(?P<end>-?\d+)}', meta.text)
    if match:
        meta.text = meta.text[:match.start()] + meta.text[match.end():]
        meta.start = int(match.group('start'))
        meta.end = int(match.group('end'))

    return meta


def _pack_event_meta(meta: EventMeta) -> str:
    text = meta.text

    if meta.start is not None and meta.end is not None:
        text = '{TIME:%d,%d}' % (meta.start, meta.end) + text

    if meta.note:
        text += '{NOTE:%s}' % (
            escape_ass_tag(meta.note.replace('\n', '\\N')))

    return text


def timestamp_to_ms(text: str) -> int:
    match = TIMESTAMP_RE.match(text)
    assert match is not None

    hours = int(match.group(1))
    minutes = int(match.group(2))
    seconds = int(match.group(3))
    frac = match.group(4)

    milliseconds: int = int(frac) * 10 ** (3 - len(frac))
    milliseconds += seconds * 1000
    milliseconds += minutes * 60000
    milliseconds += hours * 3600000
    return milliseconds


def ms_to_timestamp(milliseconds: int) -> str:
    hours, minutes, seconds, milliseconds = ms_to_times(milliseconds)
    return f'{hours:01d}:{minutes:02d}:{seconds:02d}.{milliseconds // 10:02d}'


class AssFile:
    def __init__(self) -> None:
        self.styles = StyleList()
        self.styles.insert_one(name='Default')
        self.events = EventList()
        self.meta: T.Dict[str, str] = OrderedDict()
        self.info: T.Dict[str, str] = OrderedDict()

    def write_ass(self, handle: T.IO) -> None:
        print("[Script Info]", file=handle)
        for line in NOTICE.splitlines(False):
            print(";", line, file=handle)

        # XXX: the state is mutatedâ€¦
        self.info['ScriptType'] = 'v4.00+'
        for key, value in self.info.items():
            print(key, value, sep=': ', file=handle)

        if self.meta:
            print('\n[Aegisub Project Garbage]', file=handle)
            for key, value in self.meta.items():
                print(key, value, sep=': ', file=handle)

        print('\n[V4+ Styles]', file=handle)
        print(
            'Format: Name, Fontname, Fontsize, PrimaryColour, '
            'SecondaryColour, OutlineColour, BackColour, Bold, Italic, '
            'Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, '
            'BorderStyle, Outline, Shadow, Alignment, '
            'MarginL, MarginR, MarginV, Encoding', file=handle)
        for style in self.styles.items:
            print('Style: ' + ','.join([
                style.name,
                style.font_name,
                f'{style.font_size:}',
                _color_to_ass_rgba(style.primary_color),
                _color_to_ass_rgba(style.secondary_color),
                _color_to_ass_rgba(style.outline_color),
                _color_to_ass_rgba(style.back_color),
                '-1' if style.bold else '0',
                '-1' if style.italic else '0',
                '-1' if style.underline else '0',
                '-1' if style.strike_out else '0',
                f'{style.scale_x:}',
                f'{style.scale_y:}',
                f'{style.spacing:}',
                f'{style.angle:}',
                f'{style.border_style:d}',
                f'{style.outline:}',
                f'{style.shadow:}',
                f'{style.alignment:d}',
                f'{style.margin_left:d}',
                f'{style.margin_right:d}',
                f'{style.margin_vertical:d}',
                f'{style.encoding:d}',
            ]), file=handle)

        print('\n[Events]', file=handle)
        print(
            'Format: Layer, Start, End, Style, Name, '
            'MarginL, MarginR, MarginV, Effect, Text',
            file=handle)
        for event in self.events.items:
            meta = EventMeta(event.text, event.note, event.start, event.end)
            text = _pack_event_meta(meta)
            event_type = 'Comment' if event.is_comment else 'Dialogue'
            print(event_type + ': ' + ','.join([
                f'{event.layer:d}',
                ms_to_timestamp(event.start),
                ms_to_timestamp(event.end),
                event.style,
                event.actor,
                f'{event.margin_left:d}',
                f'{event.margin_right:d}',
                f'{event.margin_vertical:d}',
                event.effect,
                text,
            ]), file=handle)

    def load_ass(self, handle: T.IO) -> None:
        self.events.clear()
        self.styles.clear()
        self.meta.clear()
        self.info.clear()

        inside_info_section = False
        inside_meta_section = False

        field_names: T.List[str] = []

        for i, line in enumerate(handle):
            line = line.strip()
            if not line:
                continue

            if SECTION_HEADING_RE.match(line):
                inside_info_section = 'Info' in line
                inside_meta_section = 'Aegisub' in line

            elif inside_info_section or inside_meta_section:
                if line.startswith(';'):
                    continue
                key, value = line.split(': ', 1)
                if inside_info_section:
                    self.info[key] = value
                elif inside_meta_section:
                    self.meta[key] = value

            elif line.startswith('Style:'):
                _, rest = line.split(': ', 1)
                field_values = rest.strip().split(',')
                field_dict = dict(zip(field_names, field_values))
                self.styles.insert_one(
                    name=field_dict['Name'],
                    font_name=field_dict['Fontname'],
                    font_size=float(field_dict['Fontsize']),
                    primary_color=_ass_rgba_to_color(
                        field_dict['PrimaryColour']),
                    secondary_color=_ass_rgba_to_color(
                        field_dict['SecondaryColour']),
                    outline_color=_ass_rgba_to_color(
                        field_dict['OutlineColour']),
                    back_color=_ass_rgba_to_color(
                        field_dict['BackColour']),
                    bold=field_dict['Bold'] == '-1',
                    italic=field_dict['Italic'] == '-1',
                    underline=field_dict['Underline'] == '-1',
                    strike_out=field_dict['StrikeOut'] == '-1',
                    scale_x=float(field_dict['ScaleX']),
                    scale_y=float(field_dict['ScaleY']),
                    spacing=float(field_dict['Spacing']),
                    angle=float(field_dict['Angle']),
                    border_style=int(field_dict['BorderStyle']),
                    outline=float(field_dict['Outline']),
                    shadow=float(field_dict['Shadow']),
                    alignment=int(field_dict['Alignment']),
                    margin_left=int(field_dict['MarginL']),
                    margin_right=int(field_dict['MarginR']),
                    margin_vertical=int(field_dict['MarginV']),
                    encoding=int(field_dict['Encoding']),
                )

            elif line.startswith('Dialogue:') or line.startswith('Comment:'):
                event_type, rest = line.split(': ', 1)
                field_values = rest.strip().split(',', len(field_names) - 1)
                field_dict = dict(zip(field_names, field_values))

                meta = _unpack_event_meta(field_dict['Text'])

                self.events.insert_one(
                    layer=int(field_dict['Layer']),
                    start=meta.start or timestamp_to_ms(field_dict['Start']),
                    end=meta.end or timestamp_to_ms(field_dict['End']),
                    style=field_dict['Style'],
                    actor=field_dict['Name'],
                    margin_left=int(field_dict['MarginL']),
                    margin_right=int(field_dict['MarginR']),
                    margin_vertical=int(field_dict['MarginV']),
                    effect=field_dict['Effect'],
                    text=meta.text,
                    note=meta.note,
                    is_comment=event_type == 'Comment',
                )

            elif line.startswith('Format:'):
                _, rest = line.split(': ', 1)
                field_names = [p.strip() for p in rest.split(',')]

            else:
                raise RuntimeError(
                    f'Corrupt ASS file at line #{i+1}: "{line}"')
